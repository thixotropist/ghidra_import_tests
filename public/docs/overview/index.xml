<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ghidra Import Testing â€“ Overview</title>
    <link>https://thixotropist.github.io/ghidra_import_tests/docs/overview/</link>
    <description>Recent content in Overview on Ghidra Import Testing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="https://thixotropist.github.io/ghidra_import_tests/docs/overview/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Glossary</title>
      <link>https://thixotropist.github.io/ghidra_import_tests/docs/overview/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://thixotropist.github.io/ghidra_import_tests/docs/overview/glossary/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;Some of the commonly used terms in this project&lt;/p&gt;

&lt;/div&gt;

&lt;dl&gt;
&lt;dt&gt;exemplar&lt;/dt&gt;
&lt;dd&gt;An example of a binary file one might expect Ghidra to accept as input.  This might be an ELF executable, an ELF object file or library of object files, a kernel load module,
or a kernel vmlinux image.  Ideally it should be relatively small and easy to screen for hidden malware.  Not all features demonstrated by the exemplar need be supported
by the current Ghidra release.&lt;/dd&gt;
&lt;dt&gt;platform&lt;/dt&gt;
&lt;dd&gt;The technology base one or more exemplars are used on.  A kernel exemplar expects to be run on top of a bootloader platform.  A Linux application exemplar may consider
the Linux kernel plus system libraries as its platform.  System libraries like libc.so can then be both exemplars and platform elements.&lt;/dd&gt;
&lt;dt&gt;crosscompiler&lt;/dt&gt;
&lt;dd&gt;A compiler capable of generating code for a processor other than the one it is running on.  An x86_64 gcc-13 compiler configured to generate riscv-64 object files would be a crosscompiler.
Crosscompilers run on either the local host platform or on a Continuous Integration test server platform, generating object files (*.o)&lt;/dd&gt;
&lt;dt&gt;linker&lt;/dt&gt;
&lt;dd&gt;A tool that takes one or more object files and resolves those runtime linkages internal to those object files.  Usually &lt;code&gt;ld&lt;/code&gt; on a Linux system.  Often generates an ELF file
or a kernel image.&lt;/dd&gt;
&lt;dt&gt;loader&lt;/dt&gt;
&lt;dd&gt;A tool - often integrated with the kernel - that loads an Elf file into RAM.  The loader finalizes runtime linkages with external objects.  The loader will often rewrite
code (aka &lt;code&gt;relaxation&lt;/code&gt;) to optimize memory references and so performance.&lt;/dd&gt;
&lt;dt&gt;sysroot&lt;/dt&gt;
&lt;dd&gt;The system root directories provide the interface between platform (kernel and system libraries) and user code.
This can be as simple as &lt;code&gt;/usr/include&lt;/code&gt; or as complicated as a &lt;code&gt;sysroot/lib/ldscripts&lt;/code&gt; holding
over 250 ld scripts detailing how a linker should generate code the kernel loader can fully process.
Crosscompiler toolchains often need to import a sysroot to build for a given kernel.  This can make for a circular dependency.&lt;/dd&gt;
&lt;dt&gt;toolchain&lt;/dt&gt;
&lt;dd&gt;A toolchain is an assembly of crosscompiler, linker, loader, and sysroot, plus a default set of options and switches for each component.  Different toolchains might share a gcc
crosscompiler but be configured for different platforms - building a kernel image, building `libc.so``, or building an executable application.&lt;/dd&gt;
&lt;dt&gt;workspace&lt;/dt&gt;
&lt;dd&gt;An environment that provides mappings between platforms and toolchains.  If you want to build an executable for a given platform, just name that platform on the command line
and the build tool will select a compatible toolchain and a &lt;em&gt;default&lt;/em&gt; set of options.  You can still override those options.&lt;/dd&gt;
&lt;dt&gt;hermetic&lt;/dt&gt;
&lt;dd&gt;Build artifacts are not affected by any local host files other than those imported with the toolchain.  A hermetic build on a Fedora platform will generate exactly the same
binary output as if built on an Ubuntu platform.  This allows remote build servers to cache build artifacts and CI/CD servers to use exactly the same build environment as a diverse
devlopment team.&lt;/dd&gt;
&lt;/dl&gt;

      </description>
    </item>
    
  </channel>
</rss>
