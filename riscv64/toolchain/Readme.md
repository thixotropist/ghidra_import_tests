# RISCV synthetic import tests

Other RISCV-64 tests in this project work with external public packages, such as contributed Fedora or Ubuntu riscv system images suitable for running
as virtual machines.  This directory is different - it compiles local C, C++, or assembly sources into object files and executables, giving more control
over compiler, assembler, linker, and loader options.  Generated objects should be short and easily screened for malware.  There is no guarantee that
the instruction sequences generated here are actually found in reality.

All of the imported Fedora RISC binaries share a common gcc toolchain and generic compiler options.
These Fedora binaries were likely generated by crosscompiler toolchains like `gcc-riscv64-linux-gnu` and `binutils-riscv64-linux-gnu`.
Toolchains can include system header files amd detailed scripts needed to create an executable the kernel can load and run.

An alternate Linux toolchain is provided as source by https://github.com/riscv/riscv-gnu-toolchain, which bundles `gcc-12`, `binutils-2_40`, at least two `libc`
system libraries, and a Linux 5.X-like sysroot.  C, C++, and fortran are all supported by this toolchain, plus many RISCV processor-specific
instruction set variants.

The immediate testing focus here is on riscv relocation codes and synchronization primitives.  Can Ghidra help identify race conditions in RISCV appliances?
For example, if the wrong `fence` memory barrier instruction was used inside a network driver kernel module, would we be able to notice this with a Ghidra inspection?

The build environment will be Google's Bazel, since it does well with cross-platform toolchains and we likely want to build exemplar code for native x86_64, RISCV-64 user,
and RISCV-64 kernel mod environments.  Hopefully we will get hermetic builds, with no native Fedora or Ubuntu libraries or linker scripts tainting the exemplar binaries we produce.

## RISCV Toolchain Imports

> How to go from `git clone https://github.com/riscv/riscv-gnu-toolchain` to the 60 MB portable toolchain tarball `/opt/bazel/risc64_linux_gnu-12.tar.xz` needed by `WORKSPACE`

Clone and build https://github.com/riscv/riscv-gnu-toolchain, configured for a RISCV-64 toolchain with C and C++ compilers. The toolchain will be installed in `/opt/riscv`.
We won't use `/opt/riscv` directly.  Instead we want a portable tarball with a defined SHA-512 checksum.

Selectively strip the executables under `/opt/riscv`, using the script toolchains/scripts/generate.sh and the three `*.files` lists of files to keep and strip.
This should generate a portable tar archive of `/opt/riscv` and another archive of the x86_64 dynamic sharable libraries needed for the toolchain.
This *should* make a portable and hermetic build environment.

> Note: a hermetic build environment should never refer to the local host computer's toolchain resources.  This includes `/usr/include`, and most of `/bin`` and `/lib`.
> If the toolchain tarball includes something like `riscv64-unknown-linux-gnu-gcc` and `riscv64-unknown-linux-gnu-ld`, then it had better include all of the dynamic libraries
> and linker scripts referenced by those executables too.

## Examples

Compile and link a traditional C Hello World program with:

```console
$ bazel build --platforms=//platforms:riscv_userspace userSpaceSamples:helloworld
INFO: Analyzed target //userSpaceSamples:helloworld (62 packages loaded, 428 targets configured).
INFO: Found 1 target...
Target //userSpaceSamples:helloworld up-to-date:
  bazel-bin/userSpaceSamples/helloworld
INFO: Elapsed time: 0.302s, Critical Path: 0.06s
INFO: 6 processes: 4 internal, 2 linux-sandbox.
INFO: Build completed successfully, 6 total actions
```

Bazel will lookup the toolchain registered for the target platform `platforms:riscv_userspace` and build the RISCV executable

```console
$ file bazel-bin/userSpaceSamples/helloworld
bazel-bin/userSpaceSamples/helloworld: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, \
     interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, not stripped
```

This gives us a very simple riscv-64 executable binary to use in integration tests of Ghidra's ELF importer.

If we wanted to compare the riscv-64 `helloworld` with the x86_64 `helloworld`, we just need to switch platforms:

```console
$ bazel build --platforms=//platforms:x86_64_userspace userSpaceSamples:helloworld
INFO: Build option --platforms has changed, discarding analysis cache.
INFO: Analyzed target //userSpaceSamples:helloworld (59 packages loaded, 255 targets configured).
INFO: Found 1 target...
Target //userSpaceSamples:helloworld up-to-date:
  bazel-bin/userSpaceSamples/helloworld
INFO: Elapsed time: 0.289s, Critical Path: 0.09s
INFO: 5 processes: 3 internal, 2 linux-sandbox.
INFO: Build completed successfully, 5 total actions

$ file bazel-bin/userSpaceSamples/helloworld
bazel-bin/userSpaceSamples/helloworld: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, \
     interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c30d405b5e819f077db5773480ffb71383da94f8, not stripped
```

