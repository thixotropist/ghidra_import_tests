#include <stdio.h>
#include <stdint.h>
#include "floatOperations.h"

// Begin general single and double floating point instructions
// Note: use a C style close to the one generated by the Ghidra decompiler
// to make matching easier. Also include store instructions to give Ghidra
// more hints about the return types.

// GCC only supports _fp16 on arm and aarch64 hosts.
// Treat _fp16 as if it were 32 bit floating point values

_fp16 fp16_result;
float fp32_result;
double fp64_result;
int32_t int32_result;
uint32_t uint32_result;
int64_t int64_result;
int64_t uint64_result;

float flw(const float *param_1) {
    fp32_result = *param_1;
    return fp32_result;
}

int32_t fcvt_w_s(const float *param_1) {
    int32_result = (int32_t) *param_1;
    return (int32_t) int32_result;
}

uint32_t fcvt_wu_s(const float *param_1) {
    uint32_result = (uint32_t) *param_1;
    return (uint32_t) *param_1;
}

int32_t fcvt_w_d(const double *param_1) {
    int32_result = (int32_t) *param_1;
    return (int32_t) int32_result;
}

uint32_t fcvt_wu_d(const double *param_1) {
    uint32_result = (uint32_t) *param_1;
    return uint32_result;
}

float fcvt_s_w(const int32_t *param_1) {
    fp32_result = (float) *param_1;
    return fp32_result;
}

float fcvt_s_wu(const uint32_t *param_1) {
    fp32_result = (float) *param_1;
    return fp32_result;
}

float fcvt_s_d(const double *param_1) {
    fp32_result = (float) *param_1;
    return fp32_result;
}

double fcvt_d_s(const float *param_1) {
    fp64_result = (double) *param_1;
    return fp64_result;
}

double fcvt_d_w(const int *param_1) {
    fp64_result = (double) *param_1;
    return fp64_result;
}

double fcvt_d_wu(const uint32_t *param_1) {
    fp64_result = (double) *param_1;
    return fp64_result;
}

// Move the single-precision value in floating-point register rs1
// represented in IEEE 754-2008 encoding to the lower 32 bits of
// integer register rd.
int32_t fmv_x_w(const float *param_1) {
    int32_t val;
    float src = *param_1;
    __asm__ __volatile__ (
        "fmv.x.w  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    int32_result = val;
    return int32_result;
}

// Move the single-precision value encoded in IEEE 754-2008 standard encoding
// from the lower 32 bits of integer register rs1 to the floating-point register rd.
float fmv_w_x(const int32_t *param_1) {
    float val;
    int32_t src = *param_1;
    __asm__ __volatile__ (
        "fmv.w.x  %0, %1" \
        : "=f" (val) \
        : "r" (src));
    fp32_result = val;
    return val;
}

// Begin half-precision floating-point instructions from the zfh extension

// half precision load
_fp16 flh(const _fp16 *param_1) {
    _fp16 val;
    __asm__ __volatile__ (
        "flh  %0, (%1)" \
        : "=f" (val) \
        : "r" (param_1));
    fp16_result = val;
    return val;
}

// half precision store
void fsh(const _fp16 *param_1, _fp16 param_2) {
    __asm__ __volatile__ (
        "fsh  %0, (%1)" \
        :: "f" (param_2), "r" (param_1) \
        : "memory"
        );
    return;
}

//FMV.X.H moves the half-precision value in floating-point register rs1 to a representation in IEEE
//754-2008 standard encoding in integer register rd, filling the upper XLEN-16 bits with copies of the
//floating-point numberâ€™s sign bit.
int32_t fmv_x_h(const _fp16 *param_1){
    int32_t val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fmv.x.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    int32_result = val;
    return val;
}

_fp16 fmv_h_x(const int16_t *param_1){
    _fp16 val;
    int16_t src = *param_1;
    __asm__ __volatile__ (
        "fmv.h.x  %0, %1" \
        : "=f" (val) \
        : "r" (src));
    fp16_result = val;
    return val;
}

// converts a half-precision floating-point number to a signed 32-bit integer,
int32_t fcvt_w_h(const _fp16 *param_1) {
    int32_t val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.w.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    int32_result = val;
    return val;
}

// converts a half-precision floating-point number to an unsigned 32-bit integer,
uint32_t fcvt_wu_h(const _fp16 *param_1) {
    uint32_t val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.wu.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    uint32_result = val;
    return val;
}

// converts a 32-bit signed integer into a half-precision floating-point number.
_fp16 fcvt_h_w(const int32_t *param_1) {
    int32_t src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fcvt.h.w  %0, %1" \
        : "=f" (val) \
        : "r" (src));
    fp16_result = val;
    return val;
}

// converts a 32-bit uint32_teger into a half-precision floating-point number.
_fp16 fcvt_h_wu(const uint32_t *param_1) {
    uint32_t src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fcvt.h.wu  %0, %1" \
        : "=f" (val) \
        : "r" (src));
    fp16_result = val;
    return val;
}

// converts a half-precision floating-point number to a signed 64-bit integer
int64_t fcvt_l_h(const _fp16 *param_1) {
    unsigned long val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.l.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    int64_result = val;
    return val;    
}

// converts a half-precision floating-point number to an unsigned 64-bit integer

uint64_t fcvt_lu_h(const _fp16 *param_1) {
    uint64_t val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.lu.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    uint64_result = val;
    return val;
}

// Convert a half-precision floating-point number to a single-precision floating-point number
float fcvt_s_h(const _fp16 *param_1) {
    float val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.s.h  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp32_result = val;
    return val;
}

// Convert a half-precision floating-point number to a double-precision floating-point number
double fcvt_d_h(const _fp16 *param_1) {
    double val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fcvt.d.h  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp64_result = val;
    return val;
}

// Convert a single-precision floating-point number to a half-precision floating-point number
_fp16 fcvt_h_s(const float *param_1) {
    float src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fcvt.h.s  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp16_result = val;
    return val;
}

// Convert a double-precision floating-point number to a half-precision floating-point number
_fp16 fcvt_h_d(const double *param_1) {
    double src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fcvt.h.d  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp16_result = val;
    return val;
}

// fp16 arithmetic
//      addition
_fp16 fadd_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fadd.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      subtraction
_fp16 fsub_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fsub.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      multiplication
_fp16 fmul_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fmul.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      division
_fp16 fdiv_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fdiv.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      return minimum
_fp16 fmin_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fmin.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      return maximum
_fp16 fmax_h(const float *param_1, const float *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fmax.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      square root
_fp16 fsqrt_h(const float *param_1)
{
    float src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fsqrt.h  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp16_result = val;
    return val;
}

// multiply and add
_fp16 fmadd_h(const float *param_1, const float *param_2, const float *param_3)
{
    float src1 = *param_1;
    float src2 = *param_2;
    float src3 = *param_3;
    _fp16 val;
    __asm__ __volatile__ (
        "fmadd.h  %0, %1, %2, %3" \
        : "=f" (val) \
        : "f" (src1), "f" (src2), "f" (src3));
    fp16_result = val;
    return val;
}

// multiply and subtract
_fp16 fmsub_h(const float *param_1, const float *param_2, const float *param_3)
{
    float src1 = *param_1;
    float src2 = *param_2;
    float src3 = *param_3;
    _fp16 val;
    __asm__ __volatile__ (
        "fmsub.h  %0, %1, %2, %3" \
        : "=f" (val) \
        : "f" (src1), "f" (src2), "f" (src3));
    fp16_result = val;
    return val;
}

// multiply and subtract negative
_fp16 fnmsub_h(const float *param_1, const float *param_2, const float *param_3)
{
    float src1 = *param_1;
    float src2 = *param_2;
    float src3 = *param_3;
    _fp16 val;
    __asm__ __volatile__ (
        "fnmsub.h  %0, %1, %2, %3" \
        : "=f" (val) \
        : "f" (src1), "f" (src2), "f" (src3));
    fp16_result = val;
    return val;
}

// sign injection returns *param_1 with sign bit from *param_2
_fp16 fsgnj_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fsgnj.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

// sign injection returns *param_1 with inverse of sign bit from *param_2
_fp16 fsgnjn_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fsgnjn.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

// sign injection returns *param_1 with xor of sign bits from *param_1 and *param_2 
_fp16 fsgnjx_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    _fp16 val;
    __asm__ __volatile__ (
        "fsgnjx.h  %0, %1, %2" \
        : "=f" (val) \
        : "f" (src1), "f" (src2));
    fp16_result = val;
    return val;
}

//      absolute value
_fp16 fabs_h(const float *param_1)
{
    float src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fabs.h  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp16_result = val;
    return val;
}

//      negation
_fp16 fneg_h(const float *param_1)
{
    float src = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fneg.h  %0, %1" \
        : "=f" (val) \
        : "f" (src));
    fp16_result = val;
    return val;
}

// classification as positive, negative, normal, subnormal, nan, ...
uint32_t fclass_h(const _fp16 *param_1) {
    uint32_t val;
    _fp16 src = *param_1;
    __asm__ __volatile__ (
        "fclass.h  %0, %1" \
        : "=r" (val) \
        : "f" (src));
    uint32_result = val;
    return val;
}

// compare equality 
int32_t feq_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    int32_t val;
    __asm__ __volatile__ (
        "feq.h  %0, %1, %2" \
        : "=r" (val) \
        : "f" (src1), "f" (src2));
    uint32_result = val;
    return val;
}

// compare less than or equal 
int32_t fle_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    int32_t val;
    __asm__ __volatile__ (
        "fle.h  %0, %1, %2" \
        : "=r" (val) \
        : "f" (src1), "f" (src2));
    uint32_result = val;
    return val;
}

// compare greater than 
int32_t fgt_h(const _fp16 *param_1, const _fp16 *param_2)
{
    float src1 = *param_1;
    float src2 = *param_2;
    int32_t val;
    __asm__ __volatile__ (
        "fgt.h  %0, %1, %2" \
        : "=r" (val) \
        : "f" (src1), "f" (src2));
    uint32_result = val;
    return val;
}

_fp16 fmv_h(const _fp16 *param_1)
{
    float src1 = *param_1;
    _fp16 val;
    __asm__ __volatile__ (
        "fmv.h  %0, %1" \
        : "=f" (val) \
        : "f" (src1));
    fp16_result = val;
    return val;
}

///@brief this never-called function helps Ghidra establish key function signatures
void dummyCalls() {
    float x = 1.0;
    double xd = 1.0;
    _fp16 xh = short_as_fp16(0x7fc0);
    int32_t i = 1;
    int16_t ih = 0x7fc0;
    uint32_t j = 1;
    printf("%f\n", flw(&x));
    printf("%f\n", flh(&xh));
    printf("%d\n", fcvt_w_s(&x));
    printf("%d\n", fcvt_wu_s(&x));
    printf("%d\n", fcvt_w_d(&xd));
    printf("%d\n", fcvt_wu_d(&xd));
    printf("%f\n", fcvt_s_w(&i));
    printf("%f\n", fcvt_s_wu(&j));
    printf("%f\n", fcvt_s_d(&xd));
    printf("%f\n", fcvt_d_s(&x));
    printf("%f\n", fcvt_d_w(&i));
    printf("%f\n", fcvt_d_wu(&j));
    printf("%d\n", fmv_x_w(&x));
    printf("%f\n", fmv_w_x(&i));
    printf("%d\n", fmv_x_h(&xh));
    printf("%f\n", fmv_h_x(&ih));
    printf("%d\n", fcvt_w_h(&xh));
    printf("%u\n", fcvt_wu_h(&xh));
    printf("%f\n", fcvt_s_h(&xh));
    printf("%f\n", fcvt_d_h(&xh));
    printf("%f\n", fcvt_h_s(&x));
    printf("%f\n", fcvt_h_d(&xd));
    printf("%f\n", fcvt_h_w(&i));
    printf("%f\n", fcvt_h_wu(&j));
    printf("%ld\n", fcvt_l_h(&xh));
    printf("%lu\n", fcvt_lu_h(&xh));
}
